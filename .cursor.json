{
  "version": 1,
  "formatOnSave": true,
  "formatOnPaste": true,
  "formatOnType": false,
  "defaultFormatter": "black",
  "formatters": {
    "black": {
      "command": "black",
      "args": ["--line-length", "88", "${file}"]
    },
    "isort": {
      "command": "isort",
      "args": ["--profile", "black", "${file}"]
    }
  },
  "linters": {
    "ruff": {
      "command": "ruff",
      "args": ["check", "${file}"],
      "rootPatterns": ["pyproject.toml"]
    },
    "mypy": {
      "command": "mypy",
      "args": ["${file}"],
      "rootPatterns": ["pyproject.toml"]
    }
  },
  "runOnSave": {
    "**/*.py": ["black", "isort", "ruff"]
  },
  "aiAssistant": {
    "enableInlineCompletion": true,
    "enableAutoCompletion": true,
    "contextStrategy": "comprehensive",
    "codeUnderstanding": {
      "includePatterns": [
        "workflows/**/*.py",
        "tests/**/*.py",
        "*.py",
        "*.yaml",
        "*.toml"
      ],
      "excludePatterns": [
        "**/__pycache__/**",
        "**/.venv/**",
        "**/venv/**",
        "**/.git/**"
      ]
    },
    "outputFormats": {
      "default": "markdown",
      "formats": {
        "markdown": {
          "description": "Human-readable format with headers and formatting",
          "useCases": ["UI display", "Kodosumi interface", "Documentation"],
          "example": "# Analysis Results\n\n## Key Insights\n\n1. **First insight**\n2. **Second insight**"
        },
        "json": {
          "description": "Machine-readable format for agent-to-agent interactions",
          "useCases": ["API responses", "Agent-to-agent communication", "Data processing"],
          "example": "{ \"summary\": \"Analysis summary\", \"insights\": [\"First insight\", \"Second insight\"] }"
        }
      },
      "rules": [
        "Always use JSON format for agent-to-agent interactions",
        "Always use markdown format for human-readable outputs",
        "Always include output_format parameter in flow interfaces",
        "Default to markdown when output_format is not specified",
        "Validate output_format to ensure it's either 'markdown' or 'json'"
      ]
    },
    "preferences": {
      "frameworks": ["ray", "crewai", "kodosumi", "exa.ai"],
      "preferredPatterns": [
        "Always use Ray for distributed processing",
        "Always use CrewAI for agent-based workflows",
        "Always use Kodosumi for serving and deployment",
        "Always use exa.ai for web search in CrewAI applications",
        "Prefer Ray's remote functions for parallelization",
        "Use Ray's actor model for stateful computations",
        "Implement CrewAI crews for complex AI agent tasks",
        "Use Kodosumi's deployment patterns for serving",
        "Use exa.ai for retrieving real-time information from the web",
        "When implementing AI agent-to-agent interactions, always use JSON output format",
        "For human-readable outputs in Kodosumi UI, use markdown format",
        "Always include output_format parameter in CrewAI flows with markdown as default"
      ],
      "avoidPatterns": [
        "Avoid using threading or multiprocessing directly, prefer Ray",
        "Avoid implementing custom serving solutions, use Kodosumi",
        "Avoid implementing agent frameworks from scratch, use CrewAI",
        "Avoid using other web search tools when exa.ai can be used",
        "Avoid implementing custom web search solutions",
        "Avoid hardcoding output formats without providing options for both human and agent consumption",
        "Avoid returning raw JSON to human users without proper formatting"
      ]
    },
    "contextFiles": [
      "workflows/crewai_flow/main.py",
      "workflows/crewai_flow/serve.py",
      "workflows/crewai_flow/templates/form.html",
      "workflows/crewai_flow/crews/first_crew/first_crew.py",
      "workflows/crewai_flow/README.md",
      "config.yaml"
    ]
  },
  "fileWatcher": {
    "patterns": ["**/*.py", "**/*.yaml", "**/*.toml", "**/*.html"],
    "ignore": ["**/__pycache__/**", "**/.venv/**", "**/venv/**", "**/.git/**"]
  },
  "snippets": {
    "python": {
      "ray-remote": {
        "prefix": "rayremote",
        "body": [
          "@ray.remote",
          "def ${1:function_name}(${2:parameters}):",
          "    \"\"\"${3:Function description}\"\"\"",
          "    ${0:pass}"
        ],
        "description": "Create a Ray remote function"
      },
      "crewai-flow-with-output-format": {
        "prefix": "crewaiflow",
        "body": [
          "class ${1:FlowName}State(BaseModel):",
          "    \"\"\"Define your flow state here.\"\"\"",
          "    output_format: str = \"markdown\"  # Default output format (markdown or json)",
          "    ${2:other_parameters}: ${3:type} = ${4:default_value}",
          "",
          "    @property",
          "    def is_valid_output_format(self) -> bool:",
          "        \"\"\"Check if the output format is valid.\"\"\"",
          "        return self.output_format.lower() in [\"markdown\", \"json\"]",
          "",
          "class ${1:FlowName}(Flow[${1:FlowName}State]):",
          "    \"\"\"Define your flow steps here.\"\"\"",
          "",
          "    @start()",
          "    def validate_inputs(self):",
          "        \"\"\"Validate the inputs to the flow.\"\"\"",
          "        # Validate output format",
          "        if not self.state.is_valid_output_format:",
          "            print(f\"Invalid output format: {self.state.output_format}. Using default (markdown).\")",
          "            self.state.output_format = \"markdown\"",
          "        ${0:pass}",
          "",
          "    def _format_as_markdown(self, data: Dict[str, Any]) -> str:",
          "        \"\"\"Format the data as a markdown string.\"\"\"",
          "        # Build the markdown output",
          "        md = [",
          "            f\"# ${5:Title}\",",
          "            \"\",",
          "            \"## ${6:Section}\",",
          "            \"\"",
          "        ]",
          "        return \"\\n\".join(md)"
        ],
        "description": "Create a CrewAI Flow with output format support"
      },
      "ray-remote-class": {
        "prefix": "rayremoteclass",
        "body": [
          "@ray.remote",
          "class ${1:ClassName}:",
          "    \"\"\"${2:Class description}\"\"\"",
          "    ",
          "    def __init__(self, ${3:parameters}):",
          "        ${4:pass}",
          "    ",
          "    def ${5:method_name}(self, ${6:parameters}):",
          "        ${0:pass}"
        ],
        "description": "Create a Ray remote class"
      },
      "crewai-agent": {
        "prefix": "crewaiagent",
        "body": [
          "agent = Agent(",
          "    name=\"${1:Agent Name}\",",
          "    role=\"${2:Agent Role}\",",
          "    goal=\"${3:Agent Goal}\",",
          "    backstory=\"${4:Agent Backstory}\",",
          "    llm=self.llm,",
          "    verbose=${5:True}",
          ")"
        ],
        "description": "Create a CrewAI Agent"
      },
      "crewai-task": {
        "prefix": "crewaitask",
        "body": [
          "task = Task(",
          "    name=\"${1:Task Name}\",",
          "    agent=${2:agent},",
          "    description=\"${3:Task Description}\",",
          "    expected_output=\"${4:Expected Output}\"",
          ")"
        ],
        "description": "Create a CrewAI Task"
      },
      "kodosumi-deploy": {
        "prefix": "kodosumiapp",
        "body": [
          "from kodosumi.serve import Launch, ServeAPI",
          "",
          "app = ServeAPI()",
          "",
          "@deployment",
          "@ingress(app)",
          "class ${1:ServiceName}:",
          "    \"\"\"${2:Service description}\"\"\"",
          "    ",
          "    @app.get(\"/\")",
          "    async def get(self, request: Request):",
          "        \"\"\"Handle GET requests.\"\"\"",
          "        ${0:pass}",
          "    ",
          "    @app.post(\"/\")",
          "    async def post(self, request: Request):",
          "        \"\"\"Handle POST requests.\"\"\"",
          "        form_data = await request.form()",
          "        return Launch(request, \"${3:module.path:function}\", {",
          "            \"${4:param_name}\": form_data.get(\"${4:param_name}\", \"\")",
          "        })"
        ],
        "description": "Create a Kodosumi service with FastAPI"
      },
      "output-format-handler": {
        "prefix": "outputformat",
        "body": [
          "# Extract output format from the form",
          "output_format = str(form_data.get(\"output_format\", \"markdown\"))",
          "",
          "# Validate output format",
          "if output_format not in [\"markdown\", \"json\"]:",
          "    output_format = \"markdown\"  # Default to markdown if invalid",
          "",
          "# Include output_format in the parameters",
          "return Launch(request, \"${1:module.path:function}\", {",
          "    \"${2:other_param}\": form_data.get(\"${2:other_param}\", \"\"),",
          "    \"output_format\": output_format",
          "})"
        ],
        "description": "Handle output format in a Kodosumi service"
      },
      "ray-cluster-init": {
        "prefix": "rayinit",
        "body": [
          "import ray",
          "",
          "# Initialize Ray or connect to existing cluster",
          "if not ray.is_initialized():",
          "    ray_address = os.environ.get(\"RAY_ADDRESS\")",
          "    if ray_address:",
          "        ray.init(address=ray_address)",
          "    else:",
          "        ray.init()",
          "    print(f\"Ray initialized: {ray.cluster_resources()}\")"
        ],
        "description": "Initialize Ray or connect to existing cluster"
      },
      "exa-web-search": {
        "prefix": "exasearch",
        "body": [
          "from langchain_community.tools.exa.exa_search import ExaSearchTool",
          "",
          "# Create an Exa search tool",
          "exa_search = ExaSearchTool(",
          "    api_key=os.environ.get(\"EXA_API_KEY\"),",
          "    max_results=${1:5}",
          ")",
          "",
          "# Add the tool to your agent",
          "agent = Agent(",
          "    name=\"${2:Research Agent}\",",
          "    role=\"${3:Web Researcher}\",",
          "    goal=\"${4:Find accurate information from the web}\",",
          "    backstory=\"${5:I am a web research specialist}\",",
          "    tools=[exa_search],",
          "    llm=self.llm,",
          "    verbose=True",
          ")"
        ],
        "description": "Create an Exa.ai web search tool for CrewAI"
      }
    }
  },
  "pathMappings": {
    "workflows": "${workspaceFolder}/workflows"
  }
} 